// Cython helper header for using Numpy efficiently.
// This provides some class definitions/preprocessing not possible in Cython.
// Parts:
// * including the right files and namespace to get unordered_map working
// * hashing convenience functions
// * Numpy half-sized float class
// * complex number comparators
// * sorting comparators (putting nans at the end and equivalent)
// * hashing functors (making all nans equivalent)
// * row comparators and hashers so that whole rows can be worked on at once
//
//
// The first two parts listed above are inspired by code licensed under the
// Boost License. Here it is:
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once

#include <limits>
#include <complex>
#include <math.h>    // isnan
#include <stddef.h>  // size_t, intptr_t on MSVC before 2010
#if !defined(_MSC_VER) || _MSC_VER >= 1600
#include <stdint.h>  // intptr_t and other sized integer types
#else
// sized integer types on MSVC before 2010
typedef   signed __int8  int8_t;
typedef   signed __int16 int16_t;
typedef   signed __int32 int32_t;
typedef   signed __int64 int64_t;
typedef unsigned __int8  uint8_t;
typedef unsigned __int16 uint16_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
// isnan on MSVC before 2010
#include <float.h>
inline bool isnan(float f) { return _isnan((double)f) != 0; }
inline bool isnan(double f) { return _isnan((double)f) != 0; }
inline bool isnan(long double f) { return _isnan((double)f) != 0; }
#endif

// Constexpr macros
#if (defined(__GNUC__) && !defined(__clang__) && !defined(__INTEL_COMPILER) && (__GNUC__ == 4 && __GNUC_MINOR__ >= 6 || __GNUC__ > 4)) || /* GCC >=4.6 */ \
    (defined(__clang__) && __clang_major__ == 3 && __clang_minor__ >= 1 || __clang_major__ > 3) || /* Clang >=3.1 */ \
    (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 1300) || /* Intel >=13.0 */ \
    (defined(_MSC_VER) && _MSC_VER >= 1900) || /* Intel >=19.0 (VS2015) */ \
    ((defined(__IBMC__) || defined(__IBMCPP__)) && __xlC__ >= 0x1201) /* IBM >=12.1 */
      #define HAVE_CONSTEXPR
#endif
// Unknown support in HP C/aC++ (__HP_cc/__HP_aCC), Oracle Solaris (__SUNPRO_C/__SUNPRO_CC), and PGI (__PGI)
#ifdef HAVE_CONSTEXPR
#define CONSTEXPR          constexpr
#define CONSTEXPR_OR_CONST constexpr
#else
#define CONSTEXPR
#define CONSTEXPR_OR_CONST const
#endif
#define STATIC_CONSTEXPR   static CONSTEXPR_OR_CONST


//////////////////// Find the unordered_map class ////////////////////
#ifdef unordered_map
#undef unordered_map
#endif

/* Headers (in order)
 * - std >= C++11: GCC <4.7.X defines __cplusplus as 1, use __GXX_EXPERIMENTAL_CXX0X__ instead
 * - ICC
 * - G++ >= 4.3.X
 * - G++ >= 3.X.X
 * - MSVC++ >= 9.0
 * - OTHERS
 */

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
#include <unordered_map>
#elif defined(__INTEL_COMPILER)
#include <ext/hash_map>
#elif defined(__GNUC__) && (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 3)
#include <tr1/unordered_map>
#elif defined(__GNUC__) && __GNUC__ >= 3
#include <ext/hash_map>
#elif defined(_MSC_VER) && ( ( _MSC_VER >= 1500 && _HAS_TR1 ) || ( _MSC_VER >= 1600 ) )
#include <unordered_map>
#else
#include <hash_map>
#endif

/* Namespace and type (in order)
 * - C++11, C++0X (std::unordered_map) / MSVC++ 2010 (std::unordered_map)
 * - STLPORT (std::hash_map)
 * - MSVC++ 9.0 (std::tr1::unordered_map) / G++ 4.3.X (std::tr1::unordered_map)
 * - MSVC++ 7.0 (stdext::hash_map)
 * - G++ 3.X.X, ICC (__gnu_cxx::hash_map)
 * - OTHERS (std::hash_map)
 */

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__) || (defined(_MSC_VER) && _MSC_VER >= 1600)
// ok
#elif defined(_STLPORT_VERSION)
#define unordered_map hash_map
namespace std { using std::hash_map; }
#elif (defined(_MSC_VER) && _MSC_VER >= 1500 && _HAS_TR1) || (defined(__GNUC__) && (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 3))
namespace std { using std::tr1::unordered_map; }
#define HASH_NAMESPACE std::tr1
#define HASH_NAMESPACE_START namespace std { namespace tr1 {
#define HASH_NAMESPACE_END   } }
#elif defined(_MSC_VER) && _MSC_VER >= 1300
#define unordered_map hash_map
namespace std { using stdext::hash_map; }
#define HASH_NAMESPACE stdext
#define HASH_NAMESPACE_START namespace stdext {
#elif (defined(__GNUC__) && __GNUC__ >= 3) || defined(__INTEL_COMPILER)
#define unordered_map hash_map
namespace std { using __gnu_cxx::hash_map; }
namespace __gnu_cxx { template<> struct hash<unsigned long long> { size_t operator()(const unsigned long long &__x) const { return (size_t)__x; } }; };
#define HASH_NAMESPACE __gnu_cxx
#define HASH_NAMESPACE_START namespace __gnu_cxx {
#else
#define unordered_map hash_map
namespace std { using std::hash_map; }
#endif
// defaults
#ifndef HASH_NAMESPACE
#define HASH_NAMESPACE std
#endif
#ifndef HASH_NAMESPACE_START
#define HASH_NAMESPACE_START namespace std {
#endif
#ifndef HASH_NAMESPACE_END
#define HASH_NAMESPACE_END }
#endif


//////////////////// Hashing Convenience Functions ////////////////////
template <typename T, template<class> class H> CONSTEXPR inline size_t hash_value(T const& v) { return H<T>()(v); }
template <typename T, template<class> class H> CONSTEXPR inline size_t hash_concat_val(size_t seed, T const& v) { return seed ^ (hash_value<T,H>(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }
                                               CONSTEXPR inline size_t hash_concat(size_t seed, const size_t& h) { return seed ^ (h + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }
template <typename T, template<class> class H> inline void hash_append_val(size_t &seed, T const& v) { seed ^= hash_value<T,H>(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2); }
                                               inline void hash_append(size_t &seed, const size_t& h) { seed ^= h + 0x9e3779b9 + (seed << 6) + (seed >> 2); }
template <typename T, template<class> class H> CONSTEXPR inline size_t hash_together(T const& v0, T const& v) { return hash_concat_val<T,H>(hash_value<T,H>(v0), v); }


//////////////////// Numpy Half-Sized Float Class ////////////////////
#include <numpy/halffloat.h>
// This encapsulates Numpy's half float into a class. This makes it so it is
// always distinct from a unit16_t and easy to use with C++ algorithms that 
// expect to be able to able to use == and <.
//
// While most of the functions are reimplemented here, conversion to/from
// float/double and the functions spacing and and nextafter are linked to the
// Numpy library.
//
// Numpy does not directly define mathematical operations on half-floats and
// that is continued here. The idea is that you should convert to float/double,
// do math, and then convert back.

union half
{
    // "npy_half" is "uint16_t"
    struct
    {
        npy_half sgn : 1;
        npy_half exp : 5;
        npy_half man : 10;
    };
    struct
    {
        npy_half : 1;
        npy_half abs : 15;
    };
    npy_half raw;
    
    template<typename IN, typename OUT> CONSTEXPR static OUT bit_copy(const IN &in) { return *(OUT*)&in; }
    
public:
    CONSTEXPR explicit inline half() : raw(0) { }
    CONSTEXPR explicit inline half(npy_half f) : raw(f) { }
    explicit inline half(float f) : raw(npy_floatbits_to_halfbits(bit_copy<float,uint32_t>(f))) { }
    explicit inline half(double f) : raw(npy_doublebits_to_halfbits(bit_copy<double,uint64_t>(f))) { }
    CONSTEXPR inline operator npy_half() const { return this->raw; }
    inline operator float() const { return bit_copy<uint32_t,float>(npy_halfbits_to_floatbits(this->raw)); }
    inline operator double() const { return bit_copy<uint64_t,double>(npy_halfbits_to_doublebits(this->raw)); }
    CONSTEXPR inline bool isnan() const { return (this->exp == 0x1fu) && (this->man != 0); }
    CONSTEXPR inline bool iszero() const { return this->abs == 0; }
    CONSTEXPR inline bool isinf() const { return this->abs == 0x7c00u; }
    CONSTEXPR inline bool isfinite() const { return this->exp == 0x1fu; }
    CONSTEXPR inline bool signbit() const { return (bool)this->sgn; }
    CONSTEXPR inline const half copysign(const half &b) const { return half((npy_half)(this->abs|(b.sgn<<15))); }
    inline const half spacing() const { return half(npy_half_spacing(this->raw)); }
    inline const half nextafter(const half &b) const { return half(npy_half_nextafter(this->raw, b.raw)); }
    CONSTEXPR inline const half operator +() const { return half(this->abs); }
    CONSTEXPR inline const half operator -() const { return half((npy_half)(this->abs|0x8000u)); }
    CONSTEXPR inline bool eq_nonan(const half &b) const { return this->raw == b.raw || (this->abs|b.abs) == 0; }
    CONSTEXPR inline bool lt_nonan(const half &b) const { return this->sgn ? (b.sgn ? this->abs>b.abs : (this->raw!=0x8000u) || (b.raw!=0x0000u)) : (!b.sgn && this->abs<b.abs); }
    CONSTEXPR inline bool le_nonan(const half &b) const { return this->sgn ? (!b.sgn || this->abs>=b.abs) : (b.sgn ? ((this->raw==0x0000u) && (b.raw==0x8000u)) : (this->abs<=b.abs)); }
    CONSTEXPR inline bool operator==(const half &b) const { return !this->isnan() && !b.isnan() && (this->raw == b.raw || (this->abs|b.abs) == 0); }
    CONSTEXPR inline bool operator!=(const half &b) const { return !(*this == b); }
    CONSTEXPR inline bool operator<(const half& b) const { return !this->isnan() && !b.isnan() && this->lt_nonan(b); }
    CONSTEXPR inline bool operator>(const half& b) const { return b < *this; }
    CONSTEXPR inline bool operator<=(const half& b) const { return !this->isnan() && !b.isnan() && this->le_nonan(b); }
    CONSTEXPR inline bool operator>=(const half& b) const { return b <= *this; }
};

STATIC_CONSTEXPR half half_zero  (npy_half(0x0000u));
STATIC_CONSTEXPR half half_pzero (npy_half(0x0000u));
STATIC_CONSTEXPR half half_nzero (npy_half(0x8000u));
STATIC_CONSTEXPR half half_one   (npy_half(0x3c00u));
STATIC_CONSTEXPR half half_negone(npy_half(0xbc00u));
STATIC_CONSTEXPR half half_pinf  (npy_half(0x7c00u));
STATIC_CONSTEXPR half half_ninf  (npy_half(0xfc00u));
STATIC_CONSTEXPR half half_nan   (npy_half(0x7e00u));
STATIC_CONSTEXPR half half_max   (npy_half(0x7bffu));

namespace std
{
//template <> struct is_float_point<half> : true_type { };
template <>
struct numeric_limits<half>
{
    // These are filled in the best they could be
    // denorms, signaling nan, tinyness before, and round style are not given or guessed
    STATIC_CONSTEXPR bool is_specialized = true; 
    STATIC_CONSTEXPR half min()    { return half(npy_half(0x0400u)); }
    STATIC_CONSTEXPR half max()    { return half(npy_half(0x7BFFu)); } // half_max
    STATIC_CONSTEXPR half lowest() { return half(npy_half(0xFBFFu)); } // -half_max
    STATIC_CONSTEXPR int digits = 11;
    STATIC_CONSTEXPR int digits10 = 3;
    STATIC_CONSTEXPR int max_digits10 = 2+11*301L/1000;
    STATIC_CONSTEXPR bool is_signed = true;
    STATIC_CONSTEXPR bool is_integer = false;
    STATIC_CONSTEXPR bool is_exact = false;
    STATIC_CONSTEXPR int radix = 2;
    STATIC_CONSTEXPR half epsilon()     { return half(npy_half(0x1400u)); }
    STATIC_CONSTEXPR half round_error() { return half(npy_half(0x3800u)); } // 0.5
    STATIC_CONSTEXPR int  min_exponent = -13;
    STATIC_CONSTEXPR int  min_exponent10 = -4;
    STATIC_CONSTEXPR int  max_exponent = 16;
    STATIC_CONSTEXPR int  max_exponent10 = 4;
    STATIC_CONSTEXPR bool has_infinity = true;
    STATIC_CONSTEXPR bool has_quiet_NaN = true;
    STATIC_CONSTEXPR bool has_signaling_NaN = false;
    STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;
    STATIC_CONSTEXPR bool has_denorm_loss = false;
    STATIC_CONSTEXPR half infinity()  { return half(npy_half(0x7c00u)); } // half_pinf
    STATIC_CONSTEXPR half quiet_NaN() { return half(npy_half(0x7e00u)); } // half_nan
    //STATIC_CONSTEXPR half& signaling_NaN() throw();
    //STATIC_CONSTEXPR half& denorm_min() throw();
    STATIC_CONSTEXPR bool is_iec559 = true;
    STATIC_CONSTEXPR bool is_bounded = true;
    STATIC_CONSTEXPR bool is_modulo = false;
    STATIC_CONSTEXPR bool traps = false;
    STATIC_CONSTEXPR bool tinyness_before = true;
    STATIC_CONSTEXPR float_round_style round_style = round_to_nearest;
};
}


//////////////////// Complex Class ////////////////////
// Create a complex class that can be easily used from Cython that works like the Numpy types (in
// terms of comparisons) and is binary-compatible (and convertible from) all available complex
// types (Numpy complex structs, C99 _Complex numbers, and C++ std::complex values). 
template <typename F>
struct complex
{
    typedef F value_type;

    F R, I;
    CONSTEXPR inline complex(const F& r = F(), const F& i = F()) : R(r), I(i) { }
    CONSTEXPR inline complex(const complex<F>& c) : R(c.R), I(c.I) { }
    CONSTEXPR inline complex(const std::complex<F>& c) : R(c.real()), I(c.imag()) { }
    template <typename F2> CONSTEXPR inline complex(const complex<F2>& c) : R((F)c.R), I((F)c.I) { }
    template <typename F2> CONSTEXPR inline complex(const std::complex<F2>& c) : R((F)c.real()), I((F)c.I) { }
#ifdef __STDC_IEC_559_COMPLEX__
    CONSTEXPR inline complex(const float _Complex& c)       : R(((float*      )&c)[0]), I(((float*      )&c)[1]) { }
    CONSTEXPR inline complex(const double _Complex& c)      : R(((double*     )&c)[0]), I(((double*     )&c)[1]) { }
    CONSTEXPR inline complex(const long double _Complex& c) : R(((long double*)&c)[0]), I(((long double*)&c)[1]) { }
#endif
    CONSTEXPR inline complex(const npy_cfloat& c)      : R(((float*      )&c)[0]), I(((float*      )&c)[1]) { }
    CONSTEXPR inline complex(const npy_cdouble& c)     : R(((double*     )&c)[0]), I(((double*     )&c)[1]) { }
    CONSTEXPR inline complex(const npy_clongdouble& c) : R(((long double*)&c)[0]), I(((long double*)&c)[1]) { }
    explicit CONSTEXPR inline complex(const float c[2])       : R(c[0]), I(c[1]) { }
    explicit CONSTEXPR inline complex(const double c[2])      : R(c[0]), I(c[1]) { }
    explicit CONSTEXPR inline complex(const long double c[2]) : R(c[0]), I(c[1]) { }

    inline complex<F>& operator=(const F& x) { this->R = x; this->I = 0; return *this; }
    template<typename F2> inline complex<F>& operator=(const complex<F2>& c) { this->R = (F)c.R; this->I = (F)c.I; return *this; }
    template<typename F2> inline complex<F>& operator=(const std::complex<F2>& c) { this->R = (F)c.real(); this->I = (F)c.imag(); return *this; }
#ifdef __STDC_IEC_559_COMPLEX__
    CONSTEXPR inline complex<F>& operator=(const float _Complex& c)       { this->R = ((float*      )&c)[0]; this->I = ((float*      )&c)[1]; return *this; }
    CONSTEXPR inline complex<F>& operator=(const double _Complex& c)      { this->R = ((double*     )&c)[0]; this->I = ((double*     )&c)[1]; return *this; }
    CONSTEXPR inline complex<F>& operator=(const long double _Complex& c) { this->R = ((long double*)&c)[0]; this->I = ((long double*)&c)[1]; return *this; }
#endif
    CONSTEXPR inline complex<F>& operator=(const npy_cfloat& c)      { this->R = ((float*      )&c)[0]; this->I = ((float*      )&c)[1]; return *this; }
    CONSTEXPR inline complex<F>& operator=(const npy_cdouble& c)     { this->R = ((double*     )&c)[0]; this->I = ((double*     )&c)[1]; return *this; }
    CONSTEXPR inline complex<F>& operator=(const npy_clongdouble& c) { this->R = ((long double*)&c)[0]; this->I = ((long double*)&c)[1]; return *this; }
    CONSTEXPR inline complex<F>& operator=(const float c[2])       { this->R = c[0]; this->I = c[1]; return *this; }
    CONSTEXPR inline complex<F>& operator=(const double c[2])      { this->R = c[0]; this->I = c[1]; return *this; }
    CONSTEXPR inline complex<F>& operator=(const long double c[2]) { this->R = c[0]; this->I = c[1]; return *this; }

    CONSTEXPR inline F real() const { return this->R; }
    CONSTEXPR inline F imag() const { return this->I; }
    inline F real(const F& x) { this->R = x; }
    inline F imag(const F& x) { this->I = x; }
    inline void set(const F& r = F(), const F& i = F()) { this->R = r; this->I = i; }
    inline void set_nan() { this->R = this->I = std::numeric_limits<F>::quiet_NaN(); }

    static CONSTEXPR inline complex<F> nan() { return complex<F>(std::numeric_limits<F>::quiet_NaN(), std::numeric_limits<F>::quiet_NaN()); }

    CONSTEXPR inline bool operator ==(const complex<F>& b) const { return this->R == b.R && this->I == b.I; }
    CONSTEXPR inline bool operator !=(const complex<F>& b) const { return this->R != b.R || this->I != b.I; }
    CONSTEXPR inline bool operator <(const complex<F>& b) const { return (this->R == b.R) ? (this->I < b.I) : (this->R < b.R); }
    CONSTEXPR inline bool operator >(const complex<F>& b) const { return (this->R == b.R) ? (this->I > b.I) : (this->R > b.R); }
    CONSTEXPR inline bool operator <=(const complex<F>& b) const { return (this->R == b.R) ? (this->I <= b.I) : (this->R <= b.R); }
    CONSTEXPR inline bool operator >=(const complex<F>& b) const { return (this->R == b.R) ? (this->I >= b.I) : (this->R >= b.R); }

    CONSTEXPR inline bool operator ==(const F& b) const { return this->R == b && this->I == 0; }
    CONSTEXPR inline bool operator !=(const F& b) const { return this->R != b || this->I != 0; }
    CONSTEXPR inline bool operator <(const F& b) const { return (this->R == b) ? (this->I < 0) : (this->R < b); }
    CONSTEXPR inline bool operator >(const F& b) const { return (this->R == b) ? (this->I > 0) : (this->R > b); }
    CONSTEXPR inline bool operator <=(const F& b) const { return (this->R == b) ? (this->I <= 0) : (this->R <= b); }
    CONSTEXPR inline bool operator >=(const F& b) const { return (this->R == b) ? (this->I >= 0) : (this->R >= b); }

    CONSTEXPR inline complex<F> operator+() { return complex<F>(+this->R, +this->I); }
    CONSTEXPR inline complex<F> operator-() { return complex<F>(-this->R, -this->I); }

    inline complex<F>& operator+=(const complex<F>& b) { this->R += b.R, this->I += b.I; return *this; }
    inline complex<F>& operator-=(const complex<F>& b) { this->R -= b.R, this->I -= b.I; return *this; }
    inline complex<F>& operator*=(const complex<F>& b) { this->set(this->R*b.R-this->I*b.I, this->R*b.I+this->I*b.R); return *this; }
    inline complex<F>& operator/=(const complex<F>& b)
    {
        F bR = b.R, bI = b.I;
        if (isnan(bR) || isnan(bI) || (bI == 0 && bR == 0)) { this->set_nan(); }
        else if ((bI < 0 ? -bI : +bI) < (bR < 0 ? -bR : +bR))
        {
            F r = bI / bR, d = bR + r * bI;
            if (isnan(d) || d == 0) { this->set_nan(); }
            else { this->set((this->R+this->I*r)/d, (this->I-this->R*r)/d); }
        }
        else
        {
            F r = bR / bI, d = bI + r * bR;
            if (isnan(d) || d == 0) { this->set_nan(); }
            else { this->set((this->R*r+this->I)/d, (this->I*r-this->R)/d); }
        }
        return *this;
    }

    inline complex<F>& operator+=(const F& b) { this->R += b; return *this; }
    inline complex<F>& operator-=(const F& b) { this->R -= b; return *this; }
    inline complex<F>& operator*=(const F& b) { this->R *= b; this->I *= b; return *this; }
    inline complex<F>& operator/=(const F& b) { if (isnan(b) || b == 0) { this->set_nan(); } else { this->R /= b; this->I /= b; } return *this; }

    CONSTEXPR inline complex<F> operator+(const complex<F>& b) const { return complex<F>(this->R+b.R, this->I+b.I); }
    CONSTEXPR inline complex<F> operator-(const complex<F>& b) const { return complex<F>(this->R-b.R, this->I-b.I); }
    CONSTEXPR inline complex<F> operator*(const complex<F>& b) const { return complex<F>(this->R*b.R-this->I*b.I, this->R*b.I+this->I*b.R); }
    inline complex<F> operator/(const complex<F>& b) const
    {
        F bR = b.R, bI = b.I;
        if (isnan(bR) || isnan(bI) || (bI == 0 && bR == 0)) { return complex<F>::nan(); }
        if ((bI < 0 ? -bI : +bI) < (bR < 0 ? -bR : +bR))
        {
            F r = bI / bR, d = bR + r * bI;
            return (isnan(d) || d == 0) ? complex<F>::nan() : complex<F>((this->R+this->I*r)/d, (this->I-this->R*r)/d);
        }
        else
        {
            F r = bR / bI, d = bI + r * bR;
            return (isnan(d) || d == 0) ? complex<F>::nan() : complex<F>((this->R*r+this->I)/d, (this->I*r-this->R)/d);
        }
    }

    CONSTEXPR inline complex<F> operator+(const F& b) const { return complex<F>(this->R+b, this->I); }
    CONSTEXPR inline complex<F> operator-(const F& b) const { return complex<F>(this->R-b, this->I); }
    CONSTEXPR inline complex<F> operator*(const F& b) const { return complex<F>(this->R*b, this->I*b); }
    CONSTEXPR inline complex<F> operator/(const F& b) const { return (isnan(b) || b == 0) ? complex<F>::nan() : complex<F>(this->R/b, this->I/b); }
};
template <typename F> CONSTEXPR inline bool operator ==(const F& a, const complex<F>& b) { return a == b.R && b.I == 0; }
template <typename F> CONSTEXPR inline bool operator !=(const F& a, const complex<F>& b) { return a != b.R || b.I != 0; }
template <typename F> CONSTEXPR inline bool operator <(const F& a, const complex<F>& b) { return (a == b.R) ? (0 < b.I) : (a < b.R); }
template <typename F> CONSTEXPR inline bool operator >(const F& a, const complex<F>& b) { return (a == b.R) ? (0 > b.I) : (a > b.R); }
template <typename F> CONSTEXPR inline bool operator <=(const F& a, const complex<F>& b) { return (a == b.R) ? (0 <= b.I) : (a <= b.R); }
template <typename F> CONSTEXPR inline bool operator >=(const F& a, const complex<F>& b) { return (a == b.R) ? (0 >= b.I) : (a >= b.R); }
template <typename F> CONSTEXPR inline complex<F> operator+(const F& a, const complex<F>& b) { return complex<F>(a+b.R, a+b.I); }
template <typename F> CONSTEXPR inline complex<F> operator-(const F& a, const complex<F>& b) { return complex<F>(a-b.R, a-b.I); }
template <typename F> CONSTEXPR inline complex<F> operator*(const F& a, const complex<F>& b) { return complex<F>(a*b.R, a*b.I); }
template <typename F> inline complex<F> operator/(const F& a, const complex<F>& b)
{
    F bR = b.R, bI = b.I;
    if (isnan(bR) || isnan(bI) || (bI == 0 && bR == 0)) { return complex<F>::nan(); }
    if ((bI < 0 ? -bI : +bI) < (bR < 0 ? -bR : +bR))
    {
        F r = bI / bR, d = bR + r * bI;
        return (isnan(d) || d == 0) ? complex<F>::nan() : complex<F>(a/d, -a*r/d);
    }
    else
    {
        F r = bR / bI, d = bI + r * bR;
        return (isnan(d) || d == 0) ? complex<F>::nan() : complex<F>(a*r/d, -a/d);
    }
}

template<class F> CONSTEXPR F real(const complex<F>& z) { return z.real(); }
CONSTEXPR float real(const float& z) { return z; }
template<class F> CONSTEXPR double real(const F& z) { return (double)z; }
CONSTEXPR long double real(const long double& z) { return z; }

template<class F> CONSTEXPR F imag(const complex<F>& z) { return z.imag(); }
CONSTEXPR float imag(const float& z) { return 0.0F; }
template<class F> CONSTEXPR double imag(const F& z) { return 0.0; }
CONSTEXPR long double imag(const long double& z) { return 0.0L; }

// Could also implement tons of functions from std::complex, like abs, arg, norm, conj, proj, polar, then regluar math functions...

typedef complex<float> _cfloat;
typedef complex<double> _cdouble;
typedef complex<long double> _clongdouble;


//////////////////// Sorting Comparisons ////////////////////
// These are designed to make it so floats and complex values sort with nans at the end.
// We implement less-than, equals, and not-equals for sorting and unique-ification.
#define LT_NAN(a, b) (isnan(b) && !isnan(a))
template <typename T> struct sort_ops
{   // general define for ints/bool
    CONSTEXPR static inline bool lt(const T& a, const T& b) { return a < b; }
    CONSTEXPR static inline bool eq(const T& a, const T& b) { return a == b; }
    CONSTEXPR static inline bool ne(const T& a, const T& b) { return a != b; }
};
template <> struct sort_ops<half>
{
    CONSTEXPR static inline bool lt(const half& a, const half& b) { return !a.isnan() && (b.isnan() || a.lt_nonan(b)); }
    CONSTEXPR static inline bool eq(const half& a, const half& b) { return a.isnan() ? b.isnan() : (!b.isnan() && a.eq_nonan(b)); }
    CONSTEXPR static inline bool ne(const half& a, const half& b) { return a.isnan() ? !b.isnan() : (b.isnan() || !a.eq_nonan(b)); }
};
template <typename F>
struct __sort_ops_flt
{
    CONSTEXPR static inline bool lt(const F& a, const F& b) { return a < b || LT_NAN(a,b); }
    CONSTEXPR static inline bool eq(const F& a, const F& b) { return a == b || (isnan(a) == isnan(b)); }
    CONSTEXPR static inline bool ne(const F& a, const F& b) { return a != b && (isnan(a) != isnan(b)); }
};
template <> struct sort_ops<float> : public __sort_ops_flt<float> { };
template <> struct sort_ops<double> : public __sort_ops_flt<double> { };
template <> struct sort_ops<long double> : public __sort_ops_flt<long double> { };
template <typename F> struct sort_ops< complex<F> >
{
    CONSTEXPR static inline bool lt(const complex<F>& a, const complex<F>& b)
    {
        F ar = a.R, br = b.R, ai = a.I, bi = b.I;
        return (ar<br) ? !LT_NAN(bi,ai) : ((ar>br) ? LT_NAN(ai,bi) : ((ar==br || (isnan(ar) && isnan(br))) ? sort_ops<F>::lt(ai,bi) : isnan(br)));
    }
    CONSTEXPR static inline bool eq(const complex<F>& a, const complex<F>& b) { return sort_ops<F>::eq(a.R, b.R) && sort_ops<F>::eq(a.I, b.I); }
    CONSTEXPR static inline bool ne(const complex<F>& a, const complex<F>& b) { return sort_ops<F>::ne(a.R, b.R) || sort_ops<F>::ne(a.I, b.I); }
};
#undef L_NAM


//////////////////// Hashing Support ////////////////////
// The hashing and equality functors used by unordered_map/set that treat nans as equal.
template <typename T>
struct npy_hash
{
    CONSTEXPR inline size_t operator()(const T& x) const { return hash_value<T,HASH_NAMESPACE::hash>(x); } // hash
    CONSTEXPR inline bool operator()(const T& x, const T& y) const { return x == y; } // equal to
};
template <> struct npy_hash<half>
{
    CONSTEXPR inline size_t operator()(const half& x) const { return x.isnan() ? (size_t)(-1) : (size_t)(x.iszero() ? 0 : (npy_half)x); }
    CONSTEXPR inline bool operator()(const half& x, const half& y) const { return x.isnan() ? y.isnan() : (!y.isnan() && x.eq_nonan(y)); }
};
#define FLT_HASH(x)
template <typename F>
struct __npy_hash_flt
{
    CONSTEXPR static inline size_t hash(const F& x) { return x!=x ? (size_t)(-1) : (size_t)(x == 0.0 ? 0 : hash_value<F,HASH_NAMESPACE::hash>(x)); }
    CONSTEXPR inline size_t operator()(const F& x) const { return hash(x); }
    CONSTEXPR inline bool operator()(const F& x, const F& y) const { return sort_ops<F>::eq(x,y); }
};
template <> struct npy_hash<float> : public __npy_hash_flt<float> { };
template <> struct npy_hash<double> : public __npy_hash_flt<double> { };
template <> struct npy_hash<long double> : public __npy_hash_flt<long double> { };
template <typename F> struct npy_hash< complex<F> >
{
    CONSTEXPR inline size_t operator()(const complex<F>& x) const { return hash_concat(__npy_hash_flt<F>::hash(x.R), __npy_hash_flt<F>::hash(x.I)); }
    CONSTEXPR inline bool operator()(const complex<F>& x, const complex<F>& y) const { return sort_ops<F>::eq(x.R, y.R) && sort_ops<F>::eq(x.I, y.I); }
};
#undef FLT_HASH


//////////////////// Row Support ////////////////////
// We define sorting operations and hashers for rows of data. The number of
// rows can be given at compile time for higher optimization or runtime for
// flexibility. Up to 4 (compile-time known) columns are hand-optimized.
#define NCOLS_RUNTIME -1
template <typename T, intptr_t ncols=NCOLS_RUNTIME>
struct row_ops
{
    static inline bool lt(const T* a, const T* b) // *a < *b
    {
        const T* end = a + ncols;
        while (a != end && sort_ops<T>::eq(*a,*b)) { ++a; ++b; }
        return a != end && sort_ops<T>::lt(*a,*b);
    }
    static inline bool ne(const T* a, const T* b) // *a != *b
    {
        const T* end = a + ncols;
        while (a != end && sort_ops<T>::eq(*a,*b)) { ++a; ++b; }
        return a != end;
    }
    static inline void cp(T* a, const T* b) // *a = *b
    {
        const T* end = a + ncols;
        *a++ = *b++;
        do { *a++ = *b++; } while (a != end);
    }
};
template <typename T>
struct row_ops<T,NCOLS_RUNTIME>
{
    static inline bool lt(const T* a, const T* b, const intptr_t ncols) // *a < *b
    {
        const T* end = a + ncols;
        while (a != end && sort_ops<T>::eq(*a,*b)) { ++a; ++b; }
        return a != end && sort_ops<T>::lt(*a,*b);
    }
    static inline bool ne(const T* a, const T* b, const intptr_t ncols) // *a != *b
    {
        const T* end = a + ncols;
        while (a != end && sort_ops<T>::eq(*a,*b)) { ++a; ++b; }
        return a != end;
    }
    static inline void cp(T* a, const T* b, const intptr_t ncols) // *a = *b
    {
        const T* end = a + ncols;
        do { *a++ = *b++; } while (a != end);
    }
};
template <typename T>
struct row_ops<T,1>
{
    CONSTEXPR static inline bool lt(const T* a, const T* b) { return sort_ops<T>::lt(a[0],b[0]); }
    CONSTEXPR static inline bool ne(const T* a, const T* b) { return sort_ops<T>::ne(a[0],b[0]); }
    static inline void cp(T* a, const T* b) { a[0] = b[0]; }
};
template <typename T>
struct row_ops<T,2>
{
    CONSTEXPR static inline bool lt(const T* a, const T* b) { return sort_ops<T>::lt(a[0],b[0]) || (sort_ops<T>::eq(a[0],b[0]) && sort_ops<T>::lt(a[1],b[1])); }
    CONSTEXPR static inline bool ne(const T* a, const T* b) { return sort_ops<T>::ne(a[0],b[0]) || sort_ops<T>::ne(a[1],b[1]); }
    static inline void cp(T* a, const T* b) { a[0] = b[0]; a[1] = b[1]; }
};
template <typename T>
struct row_ops<T,3>
{
    CONSTEXPR static inline bool lt(const T* a, const T* b) { return sort_ops<T>::lt(a[0],b[0]) || (sort_ops<T>::eq(a[0],b[0]) && (sort_ops<T>::lt(a[1],b[1]) || (sort_ops<T>::eq(a[1],b[1]) && sort_ops<T>::lt(a[2],b[2])))); }
    CONSTEXPR static inline bool ne(const T* a, const T* b) { return sort_ops<T>::ne(a[0],b[0]) || sort_ops<T>::ne(a[1],b[1]) || sort_ops<T>::ne(a[2],b[2]); }
    static inline void cp(T* a, const T* b) { a[0] = b[0]; a[1] = b[1]; a[2] = b[2]; }
};
template <typename T>
struct row_ops<T,4>
{
    CONSTEXPR static inline bool lt(const T* a, const T* b) { return sort_ops<T>::lt(a[0],b[0]) || (sort_ops<T>::eq(a[0],b[0]) && (sort_ops<T>::lt(a[1],b[1]) || (sort_ops<T>::eq(a[1],b[1]) && (sort_ops<T>::lt(a[2],b[2]) || (sort_ops<T>::eq(a[2],b[2]) && sort_ops<T>::lt(a[3],b[3])))))); }
    CONSTEXPR static inline bool ne(const T* a, const T* b) { return sort_ops<T>::ne(a[0],b[0]) || sort_ops<T>::ne(a[1],b[1]) || sort_ops<T>::ne(a[2],b[2]) || sort_ops<T>::ne(a[3],b[3]); }
    static inline void cp(T* a, const T* b) { a[0] = b[0]; a[1] = b[1]; a[2] = b[2]; a[3] = b[3]; }
};
// Hasher for rows
template <typename T, intptr_t ncols=NCOLS_RUNTIME>
struct row_hash
{
    inline size_t operator()(const T* x) const // hash
    {
        size_t seed = 0;
        for (const T* end = x+this->ncols; x != end; ++x) { hash_append_val<T,npy_hash>(seed, *x); }
        return seed;
    }
    inline bool operator()(const T* x, const T* y) const // equal_to
    {
        const T* end;
        for (end = x + ncols; x != end && sort_ops<T>::eq(*x,*y); ++x, ++y);
        return x == end;
    }
};
template <typename T>
struct row_hash<T,NCOLS_RUNTIME>
{
    const intptr_t ncols;
    CONSTEXPR inline row_hash(intptr_t ncols) : ncols(ncols) { }
    inline size_t operator()(const T* x) const
    {
        size_t seed = 0;
        for (const T* end = x+this->ncols; x != end; ++x) { hash_append_val<T,npy_hash>(seed, *x); }
        return seed;
    }
    inline bool operator()(const T* x, const T* y) const
    {
        const T* end;
        for (end = x + this->ncols; x != end && sort_ops<T>::eq(*x,*y); ++x, ++y);
        return x == end;
    }
};
template <typename T>
struct row_hash<T,1>
{
    CONSTEXPR inline size_t operator()(const T* x) const { return hash_value<T,npy_hash>(x[0]); }
    CONSTEXPR inline bool operator()(const T* x, const T* y) const { return sort_ops<T>::eq(x[0],y[0]); }
};
template <typename T>
struct row_hash<T,2>
{
    CONSTEXPR inline size_t operator()(const T* x) const { return hash_together<T,npy_hash>(x[0], x[1]); }
    CONSTEXPR inline bool operator()(const T* x, const T* y) const { return sort_ops<T>::eq(x[0],y[0]) && sort_ops<T>::eq(x[1],y[1]); }
};
template <typename T>
struct row_hash<T,3>
{
    CONSTEXPR inline size_t operator()(const T* x) const { return hash_concat_val<T,npy_hash>(hash_together<T,npy_hash>(x[0], x[1]), x[2]); }
    CONSTEXPR inline bool operator()(const T* x, const T* y) const { return sort_ops<T>::eq(x[0],y[0]) && sort_ops<T>::eq(x[1],y[1]) && sort_ops<T>::eq(x[2],y[2]); }
};
template <typename T>
struct row_hash<T,4>
{
    CONSTEXPR inline size_t operator()(const T* x) const { return hash_concat_val<T,npy_hash>(hash_concat_val<T,npy_hash>(hash_together<T,npy_hash>(x[0], x[1]), x[2]), x[3]); }
    CONSTEXPR inline bool operator()(const T* x, const T* y) const { return sort_ops<T>::eq(x[0],y[0]) && sort_ops<T>::eq(x[1],y[1]) && sort_ops<T>::eq(x[2],y[2]) && sort_ops<T>::eq(x[3],y[3]); }
};
